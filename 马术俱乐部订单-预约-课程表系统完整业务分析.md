基于最新的优化，我来全面总结订单、预约管理、课程表三者之间的状态流转、逻
辑和交互关系。

🏗️ 系统架构概览

核心三层架构

📋 订单层 (Order)     ↔️ 🎯 预约层 (Booking)     ↔️ 📅 课程表层
(Schedule)
业务管理              资源调度                时间安排

📊 完整状态流转图

🔄 三层状态映射关系

| 业务阶段 | 订单状态  | 预约状态  | 课表状态  | 用户操作  | 系统行为
|
|------|-------|-------|-------|-------|-------------|
| 下单阶段 | 1-待支付 | 1-待确认 | -     | 用户下单  | 创建订单+预约
|
| 支付阶段 | 2-已支付 | 2-已确认 | 1-待上课 | 用户支付  |
自动确认预约+生成课表 |
| 核销阶段 | 3-已核销 | 4-已完成 | 3-已完成 | 管理员核销 | 直接完成预约
|
| 取消分支 | 4-已取消 | 5-已取消 | 4-已取消 | 手动取消  | 全链路取消
|
| 退款分支 | 5-已退款 | 5-已取消 | 4-已取消 | 申请退款  | 全链路取消
|

🎯 业务流程详解

阶段一：订单创建 → 预约生成

// OrderService.createOrder()
用户下单 → {
1. 创建订单主表 (OrderEntity)
- 订单状态：1-待支付
- 总金额计算

    2. 创建订单明细 (OrderItemEntity)
       - 商品信息、教练、期望时间

    3. 自动生成预约 (BookingEntity)
       - 预约状态：1-待确认
       - 时间安排、资源预分配
}

关键代码逻辑:
// 第120行：订单创建后自动生成预约
ResponseDTO<Void> bookingResult = orderBookingService
.createBookingsFromOrder(orderEntity.getOrderId(), orderItems);

阶段二：支付确认 → 预约激活 → 课表生成

// OrderService.handleOrderStatusChange() - 核心优化点
订单支付 → {
订单状态：1-待支付 → 2-已支付
↓ 触发预约确认
预约状态：1-待确认 → 2-已确认
↓ 触发课表生成
课表状态：- → 1-待上课
}

关键代码逻辑:
case 2: // 已支付 -> 自动确认所有预约并生成课表

orderBookingService.confirmBookingsByOrderId(orderEntity.getOrderId());
break;

阶段三：核销完成 → 业务闭环

// 简化后的核销流程
预约核销 → {
预约状态：2-已确认 → 4-已完成  // 跳过进行中状态
↓ 同步更新
课表状态：1-待上课 → 3-已完成
↓ 检查完成
订单状态：2-已支付 → 3-已核销  // 所有预约完成后
}

🎛️ 核心交互逻辑

1️⃣ 订单 → 预约 的驱动机制

创建驱动

// OrderBookingService.createBookingsFromOrder()
for (OrderItemEntity orderItem : orderItems) {
for (int i = 0; i < orderItem.getQuantity(); i++) {
BookingEntity booking = new BookingEntity();
// 基于订单明细创建预约
booking.setOrderId(orderId);
booking.setCoachId(orderItem.getCoachId());
booking.setStartTime(calculateStartTime(orderItem, i));
booking.setBookingStatus(1); // 待确认
}
}

状态驱动

// 订单状态变更 → 预约状态联动
switch (orderStatus) {
case 2: // 支付 → 确认预约
orderBookingService.confirmBookingsByOrderId(orderId);
case 3: // 核销 → 完成预约
orderBookingService.completeBookingsByOrderId(orderId);
case 4: // 取消 → 取消预约
orderBookingService.cancelBookingsByOrderId(orderId);
}

2️⃣ 预约 → 课表 的同步机制

课表生成

// ScheduleService.createScheduleFromBooking()
预约确认时 → {
LessonScheduleEntity schedule = new LessonScheduleEntity();
schedule.setBookingId(booking.getBookingId());

schedule.setLessonStatus(mapBookingStatusToLessonStatus(bookingStatus));
// 生成课单号、设置教练马匹、时间安排
}

状态同步

// 预约状态 → 课表状态映射
private Integer mapBookingStatusToLessonStatus(Integer bookingStatus) {
switch (bookingStatus) {
case 1: case 2: return 1; // 待确认/已确认 → 待上课
case 4: return 3;         // 已完成 → 已完成
case 5: return 4;         // 已取消 → 已取消
}
}

3️⃣ 三层数据关联

-- 数据库关联关系
订单表 (m_order)
├── order_id (PK)
└── order_status

订单明细表 (m_order_item)
├── id (PK)
├── order_id (FK) → m_order.order_id
└── coach_id, preferred_time

预约表 (m_booking)
├── booking_id (PK)
├── order_id (FK) → m_order.order_id
├── order_item_id (FK) → m_order_item.id
└── booking_status

课表表 (m_lesson_schedule)
├── schedule_id (PK)
├── booking_id (FK) → m_booking.booking_id
└── lesson_status

🎨 前端操作界面

📱 订单详情页面 (OrderDetail.vue)

预约操作区域：
- 状态显示：待确认 | 待核销 | 已核销 | 已取消
- 操作按钮：[核销] (仅已确认状态显示)
- 权限控制：business:booking:complete

📋 预约管理页面 (BookingList.vue)

预约操作：
- 确认预约：status 1→2 (手动确认)
- 核销预约：status 2→4 (跳过进行中)
- 取消预约：status ≤2→5
- 批量操作：支持批量确认

🔧 技术实现特点

⚡ 自动化程度

- 100%自动: 订单支付 → 预约确认 → 课表生成
- 一键操作: 预约核销 (跳过进行中状态)
- 状态联动: 三层状态实时同步

🛡️ 数据一致性保障

- 事务管理: 所有关键操作使用 @Transactional
- 状态校验: 严格的状态流转验证
- 异常处理: 支付成功但预约失败有专门处理

📈 业务优化点

- 流程简化: 删除"开始上课"环节
- 权限精确: 不同角色不同操作权限
- 日志完整: 全链路操作日志追踪

🎯 实际使用场景

👤 用户端操作流程

1. 用户选择课程、教练、时间 → 下单
2. 用户支付订单 → 系统自动确认预约并生成课表
3. 用户到店上课 → 教练/前台点击"核销"
4. 系统自动完成预约 → 订单变为已核销

👨‍💼 管理端操作流程

1. 查看待核销预约列表
2. 确认学员到场后点击"核销"按钮
3. 系统自动完成状态流转
4. 生成课程记录和费用结算

🚀 系统架构优势

✅ 业务优势

- 自动化高: 减少人工干预，提高效率
- 流程清晰: 状态流转逻辑清晰可追溯
- 操作简单: 一键核销，降低操作复杂度
- 数据准确: 三层状态强一致性保障

🔧 技术优势

- 松耦合: 订单、预约、课表职责分离
- 可扩展: 支持多种课程类型和业务场景
- 高可靠: 事务保护和异常恢复机制
- 易维护: 清晰的分层架构和状态管理

这套系统通过预约模块作为核心纽带，实现了从订单下单到课程完成的全流程自动
化管理，形成了马术俱乐部完整的业务管理闭环。
