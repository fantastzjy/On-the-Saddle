# 预约管理系统前后端优化方案

## 🎯 总体目标

基于简化业务流程，优化预约管理系统的前后端实现，增加改期功能，保持系统简洁性的同时提升用户体验。

## 📊 业务流程设计

### 简化后的核心流程
```
订单支付成功 → 自动确认预约(2) → 自动生成课表(1-待上课)
                    ↓
已确认预约 → [核销] 记录时间，状态不变
           → [改期] 修改预约时间，同步更新课表
           → [取消] 变更状态为已取消(5)
```

### 关键业务规则
1. **自动化确认**: 订单支付后自动确认预约，无需手动操作
2. **状态简化**: 核销只记录时间，不改变预约和课表状态
3. **改期功能**: 支持修改预约时间，自动检测冲突，同步更新课表
4. **数据一致性**: 预约和课表数据始终保持同步

## 🔧 后端优化方案

### A. BookingService 功能增强

#### 1. 简化核销逻辑
```java
@Transactional
public ResponseDTO<Void> checkinBooking(Long bookingId) {
    BookingEntity booking = bookingDao.selectById(bookingId);
    if (booking.getBookingStatus() != 2) {
        return ResponseDTO.userErrorParam("只有已确认的预约才能核销");
    }
    
    // 只记录核销时间，不改变状态
    booking.setArrivalTime(LocalDateTime.now());
    booking.setUpdateTime(LocalDateTime.now());
    bookingDao.updateById(booking);
    
    return ResponseDTO.ok();
}
```

#### 2. 新增改期功能
```java
@Transactional
public ResponseDTO<Void> rescheduleBooking(Long bookingId, BookingRescheduleForm rescheduleForm) {
    // 1. 校验预约状态
    BookingEntity booking = bookingDao.selectById(bookingId);
    if (booking.getBookingStatus() != 2) {
        return ResponseDTO.userErrorParam("只有已确认的预约才能改期");
    }
    
    // 2. 校验新时间的可用性（教练、马匹冲突检测）
    ConflictCheckResult conflictResult = checkTimeConflict(
        booking.getCoachId(), 
        booking.getHorseId(),
        rescheduleForm.getNewStartTime(),
        rescheduleForm.getNewEndTime(),
        bookingId // 排除当前预约
    );
    
    if (conflictResult.hasConflict()) {
        return ResponseDTO.userErrorParam("新时间段存在冲突：" + conflictResult.getConflictMessage());
    }
    
    // 3. 更新预约时间
    booking.setStartTime(rescheduleForm.getNewStartTime());
    booking.setEndTime(rescheduleForm.getNewEndTime());
    booking.setUpdateTime(LocalDateTime.now());
    bookingDao.updateById(booking);
    
    // 4. 同步更新课表时间
    LessonScheduleEntity schedule = scheduleDao.selectByBookingId(bookingId);
    if (schedule != null) {
        schedule.setStartTime(rescheduleForm.getNewStartTime());
        schedule.setEndTime(rescheduleForm.getNewEndTime());
        schedule.setLessonDate(rescheduleForm.getNewStartTime().toLocalDate());
        scheduleDao.updateById(schedule);
    }
    
    // 5. 记录改期日志
    operateLogService.recordReschedule(bookingId, booking.getStartTime(), rescheduleForm.getNewStartTime());
    
    return ResponseDTO.ok();
}
```

#### 3. 增强时间冲突检测
```java
public ConflictCheckResult checkTimeConflict(Long coachId, Long horseId, 
                                           LocalDateTime startTime, LocalDateTime endTime, 
                                           Long excludeBookingId) {
    ConflictCheckResult result = new ConflictCheckResult();
    
    // 检查教练时间冲突
    List<BookingEntity> coachConflicts = bookingDao.findCoachTimeConflicts(
        coachId, startTime, endTime, excludeBookingId);
    if (!coachConflicts.isEmpty()) {
        result.addConflict("教练", coachConflicts);
    }
    
    // 检查马匹时间冲突  
    List<BookingEntity> horseConflicts = bookingDao.findHorseTimeConflicts(
        horseId, startTime, endTime, excludeBookingId);
    if (!horseConflicts.isEmpty()) {
        result.addConflict("马匹", horseConflicts);
    }
    
    return result;
}
```

### B. 新增数据传输对象

#### 1. 改期表单对象
```java
@Data
public class BookingRescheduleForm {
    @NotNull(message = "预约ID不能为空")
    private Long bookingId;
    
    @NotNull(message = "新开始时间不能为空")
    @Future(message = "新开始时间必须是未来时间")
    private LocalDateTime newStartTime;
    
    @NotNull(message = "新结束时间不能为空")  
    private LocalDateTime newEndTime;
    
    private String rescheduleReason; // 改期原因
    
    @AssertTrue(message = "结束时间必须晚于开始时间")
    public boolean isValidTimeRange() {
        return newEndTime != null && newStartTime != null && 
               newEndTime.isAfter(newStartTime);
    }
}
```

#### 2. 冲突检测结果对象
```java
@Data
public class ConflictCheckResult {
    private boolean hasConflict = false;
    private List<ConflictDetail> conflicts = new ArrayList<>();
    private String conflictMessage;
    
    public void addConflict(String resourceType, List<BookingEntity> conflictBookings) {
        if (!conflictBookings.isEmpty()) {
            this.hasConflict = true;
            conflicts.add(new ConflictDetail(resourceType, conflictBookings));
            updateConflictMessage();
        }
    }
    
    private void updateConflictMessage() {
        this.conflictMessage = conflicts.stream()
            .map(c -> c.getResourceType() + "时间冲突")
            .collect(Collectors.joining("，"));
    }
}
```

### C. BookingController 接口增强

```java
@PostMapping("/reschedule")
@Operation(summary = "预约改期")
public ResponseDTO<Void> rescheduleBooking(@RequestBody @Valid BookingRescheduleForm rescheduleForm) {
    return bookingService.rescheduleBooking(rescheduleForm.getBookingId(), rescheduleForm);
}

@PostMapping("/checkRescheduleConflict")  
@Operation(summary = "改期冲突检测")
public ResponseDTO<ConflictCheckResult> checkRescheduleConflict(@RequestBody @Valid BookingRescheduleForm rescheduleForm) {
    BookingEntity booking = bookingService.getById(rescheduleForm.getBookingId());
    if (booking == null) {
        return ResponseDTO.userErrorParam("预约不存在");
    }
    
    ConflictCheckResult result = bookingService.checkTimeConflict(
        booking.getCoachId(), booking.getHorseId(),
        rescheduleForm.getNewStartTime(), rescheduleForm.getNewEndTime(),
        rescheduleForm.getBookingId()
    );
    
    return ResponseDTO.ok(result);
}
```

### D. 数据库层优化

#### 1. BookingDao 新增查询方法
```java
/**
 * 查询教练时间冲突的预约
 */
List<BookingEntity> findCoachTimeConflicts(@Param("coachId") Long coachId,
                                         @Param("startTime") LocalDateTime startTime,
                                         @Param("endTime") LocalDateTime endTime,
                                         @Param("excludeBookingId") Long excludeBookingId);

/**
 * 查询马匹时间冲突的预约  
 */
List<BookingEntity> findHorseTimeConflicts(@Param("horseId") Long horseId,
                                         @Param("startTime") LocalDateTime startTime,
                                         @Param("endTime") LocalDateTime endTime,
                                         @Param("excludeBookingId") Long excludeBookingId);
```

#### 2. BookingMapper.xml 新增SQL
```xml
<select id="findCoachTimeConflicts" resultType="BookingEntity">
    SELECT * FROM m_booking 
    WHERE coach_id = #{coachId}
    AND booking_status = 2 
    AND booking_id != #{excludeBookingId}
    AND (
        (start_time &lt;= #{startTime} AND end_time &gt; #{startTime}) OR
        (start_time &lt; #{endTime} AND end_time &gt;= #{endTime}) OR  
        (start_time &gt;= #{startTime} AND end_time &lt;= #{endTime})
    )
</select>

<select id="findHorseTimeConflicts" resultType="BookingEntity">
    SELECT * FROM m_booking 
    WHERE horse_id = #{horseId}
    AND booking_status = 2
    AND booking_id != #{excludeBookingId}
    AND (
        (start_time &lt;= #{startTime} AND end_time &gt; #{startTime}) OR
        (start_time &lt; #{endTime} AND end_time &gt;= #{endTime}) OR
        (start_time &gt;= #{startTime} AND end_time &lt;= #{endTime})
    )
</select>
```

## 🎨 前端优化方案

### A. BookingList.vue 操作按钮优化

#### 1. 重新设计操作按钮逻辑
```vue
<template #action="{ record }">
  <a-space>
    <a @click="showBookingDetail(record)" v-privilege="'business:booking:detail'">
      详情
    </a>
    
    <!-- 已确认且未核销：显示核销和改期 -->
    <template v-if="record.bookingStatus === 2 && !record.arrivalTime">
      <a 
        @click="checkinBooking(record)" 
        v-privilege="'business:booking:checkin'"
        style="color: #52c41a;"
      >
        核销
      </a>
      <a 
        @click="showRescheduleModal(record)" 
        v-privilege="'business:booking:reschedule'"
        style="color: #1890ff;"
      >
        改期
      </a>
    </template>
    
    <!-- 已确认但未核销：可以取消 -->
    <a 
      @click="cancelBooking(record)" 
      v-if="record.bookingStatus === 2 && !record.arrivalTime"
      v-privilege="'business:booking:cancel'"
      style="color: #ff4d4f;"
    >
      取消
    </a>
  </a-space>
</template>
```

#### 2. 状态显示优化
```vue
<template #bookingStatus="{ record }">
  <a-space direction="vertical" size="small">
    <a-tag :color="getStatusColor(record.bookingStatus)">
      {{ getStatusName(record.bookingStatus) }}
    </a-tag>
    <a-tag v-if="record.arrivalTime" color="success" size="small">
      已核销 {{ formatTime(record.arrivalTime) }}
    </a-tag>
  </a-space>
</template>
```

### B. 新增改期弹窗组件

#### 创建 BookingRescheduleModal.vue
```vue
<template>
  <a-modal
    v-model:open="visible"
    title="预约改期"
    @ok="handleReschedule"
    @cancel="handleCancel"
    :confirmLoading="loading"
    width="600px"
  >
    <a-form
      ref="formRef"
      :model="rescheduleForm"
      :rules="formRules"
      :label-col="{ span: 6 }"
      :wrapper-col="{ span: 16 }"
    >
      <a-form-item label="当前时间">
        <span>{{ formatDateTime(bookingInfo.startTime) }} - {{ formatDateTime(bookingInfo.endTime) }}</span>
      </a-form-item>
      
      <a-form-item label="新开始时间" name="newStartTime">
        <a-date-picker
          v-model:value="rescheduleForm.newStartTime"
          show-time
          placeholder="请选择新开始时间"
          :disabled-date="disabledDate"
          format="YYYY-MM-DD HH:mm"
          valueFormat="YYYY-MM-DD HH:mm:ss"
        />
      </a-form-item>
      
      <a-form-item label="新结束时间" name="newEndTime">
        <a-date-picker
          v-model:value="rescheduleForm.newEndTime"
          show-time  
          placeholder="请选择新结束时间"
          :disabled-date="disabledDate"
          format="YYYY-MM-DD HH:mm"
          valueFormat="YYYY-MM-DD HH:mm:ss"
        />
      </a-form-item>
      
      <a-form-item label="改期原因" name="rescheduleReason">
        <a-textarea
          v-model:value="rescheduleForm.rescheduleReason"
          placeholder="请输入改期原因"
          :rows="3"
        />
      </a-form-item>
      
      <!-- 冲突检测结果显示 -->
      <a-alert
        v-if="conflictResult && conflictResult.hasConflict"
        :message="`时间冲突：${conflictResult.conflictMessage}`"
        type="error"
        show-icon
        style="margin-top: 16px;"
      />
    </a-form>
  </a-modal>
</template>

<script setup>
import { ref, reactive, watch } from 'vue';
import { message } from 'ant-design-vue';
import { bookingApi } from '/@/api/business/booking/booking-api';
import dayjs from 'dayjs';

// Props
const props = defineProps({
  visible: Boolean,
  bookingInfo: Object
});

// Emits
const emit = defineEmits(['update:visible', 'success']);

// 表单数据
const rescheduleForm = reactive({
  bookingId: null,
  newStartTime: null,
  newEndTime: null,
  rescheduleReason: ''
});

// 冲突检测结果
const conflictResult = ref(null);
const loading = ref(false);

// 表单验证规则
const formRules = {
  newStartTime: [{ required: true, message: '请选择新开始时间' }],
  newEndTime: [{ required: true, message: '请选择新结束时间' }],
  rescheduleReason: [{ required: true, message: '请输入改期原因' }]
};

// 监听时间变化，自动检测冲突
watch([() => rescheduleForm.newStartTime, () => rescheduleForm.newEndTime], 
  async ([newStart, newEnd]) => {
    if (newStart && newEnd && props.bookingInfo) {
      await checkConflict();
    }
  });

// 冲突检测
const checkConflict = async () => {
  try {
    const res = await bookingApi.checkRescheduleConflict({
      bookingId: props.bookingInfo.bookingId,
      newStartTime: rescheduleForm.newStartTime,
      newEndTime: rescheduleForm.newEndTime
    });
    
    if (res.ok) {
      conflictResult.value = res.data;
    }
  } catch (error) {
    console.error('冲突检测失败', error);
  }
};

// 提交改期
const handleReschedule = async () => {
  try {
    loading.value = true;
    
    // 检查是否有冲突
    if (conflictResult.value?.hasConflict) {
      message.error('存在时间冲突，无法改期');
      return;
    }
    
    const res = await bookingApi.rescheduleBooking({
      ...rescheduleForm,
      bookingId: props.bookingInfo.bookingId
    });
    
    if (res.ok) {
      message.success('改期成功');
      emit('success');
      handleCancel();
    } else {
      message.error(res.msg || '改期失败');
    }
  } catch (error) {
    message.error('改期失败');
  } finally {
    loading.value = false;
  }
};

// 取消改期
const handleCancel = () => {
  Object.assign(rescheduleForm, {
    bookingId: null,
    newStartTime: null,
    newEndTime: null, 
    rescheduleReason: ''
  });
  conflictResult.value = null;
  emit('update:visible', false);
};

// 禁用过去的日期
const disabledDate = (current) => {
  return current && current < dayjs().startOf('day');
};

const formatDateTime = (dateTime) => {
  if (!dateTime) return '';
  return dayjs(dateTime).format('YYYY-MM-DD HH:mm');
};
</script>
```

### C. BookingDetail.vue 快速操作优化

```vue
<!-- 快速操作区域 -->
<a-card title="快速操作" v-if="bookingDetail.bookingStatus === 2">
  <a-space>
    <!-- 未核销时显示核销和改期按钮 -->
    <template v-if="!bookingDetail.arrivalTime">
      <a-button 
        type="primary" 
        @click="checkinBooking"
        v-privilege="'business:booking:checkin'"
      >
        <LoginOutlined />
        核销预约
      </a-button>
      
      <a-button 
        @click="showRescheduleModal"
        v-privilege="'business:booking:reschedule'"
      >
        <SwapOutlined />
        改期
      </a-button>
    </template>
    
    <!-- 已核销时显示核销记录 -->
    <template v-else>
      <a-descriptions title="核销记录" :column="1">
        <a-descriptions-item label="核销时间">
          {{ formatDateTime(bookingDetail.arrivalTime) }}
        </a-descriptions-item>
      </a-descriptions>
    </template>
  </a-space>
</a-card>

<!-- 改期弹窗 -->
<BookingRescheduleModal
  v-model:visible="rescheduleModalVisible"
  :booking-info="bookingDetail"
  @success="onRescheduleSuccess"
/>
```

### D. 前端 API 层增强

#### 更新 booking-api.js
```javascript
// 改期相关接口
export const bookingApi = {
  // ... 现有接口
  
  // 预约改期
  rescheduleBooking(data) {
    return request.post('/api/admin/booking/reschedule', data);
  },
  
  // 改期冲突检测
  checkRescheduleConflict(data) {
    return request.post('/api/admin/booking/checkRescheduleConflict', data);
  }
};
```

## 📋 实施计划

### 🔴 第一阶段：核心功能实施（立即开始）

#### 后端任务
- [ ] 1.1 创建 `BookingRescheduleForm` 表单对象
- [ ] 1.2 创建 `ConflictCheckResult` 结果对象
- [ ] 1.3 简化 `BookingService.checkinBooking()` 方法
- [ ] 1.4 新增 `BookingService.rescheduleBooking()` 方法
- [ ] 1.5 实现 `BookingService.checkTimeConflict()` 冲突检测
- [ ] 1.6 在 `BookingDao` 中添加冲突查询方法
- [ ] 1.7 在 `BookingMapper.xml` 中添加冲突检测SQL
- [ ] 1.8 在 `BookingController` 中添加改期接口

#### 前端任务
- [ ] 1.9 创建 `BookingRescheduleModal.vue` 改期弹窗组件
- [ ] 1.10 优化 `BookingList.vue` 操作按钮显示逻辑
- [ ] 1.11 优化 `BookingList.vue` 状态显示
- [ ] 1.12 更新 `BookingDetail.vue` 快速操作区域
- [ ] 1.13 更新 `booking-api.js` 添加改期接口

### 🟡 第二阶段：功能完善（1周内完成）

#### 后端任务
- [ ] 2.1 完善冲突检测的数据库查询优化
- [ ] 2.2 添加改期操作日志记录功能
- [ ] 2.3 增强异常处理和数据校验
- [ ] 2.4 添加改期权限控制

#### 前端任务
- [ ] 2.5 优化改期弹窗的用户体验
- [ ] 2.6 添加冲突检测的实时提示效果
- [ ] 2.7 完善状态显示和交互反馈
- [ ] 2.8 添加改期成功后的数据刷新

### 🟢 第三阶段：体验优化（后续迭代）

- [ ] 3.1 添加改期历史记录查询功能
- [ ] 3.2 增加批量改期功能（如需要）
- [ ] 3.3 优化移动端适配
- [ ] 3.4 添加改期通知推送功能
- [ ] 3.5 添加改期统计报表

## 📊 验收标准

### 功能验收
- [ ] 核销功能：只记录时间，不改变状态
- [ ] 改期功能：支持时间修改，自动冲突检测
- [ ] 数据同步：预约改期后课表时间同步更新
- [ ] 权限控制：不同角色有对应的操作权限

### 性能验收
- [ ] 冲突检测响应时间 < 500ms
- [ ] 改期操作响应时间 < 1s
- [ ] 页面加载时间 < 2s

### 用户体验验收
- [ ] 操作按钮显示逻辑清晰
- [ ] 冲突提示实时且准确
- [ ] 错误提示信息友好
- [ ] 成功操作有明确反馈

## 🎯 预期效果

### 业务流程优化
- ✅ **简化核销**: 只记录时间，不变更状态
- ✅ **新增改期**: 支持时间调整，自动冲突检测
- ✅ **保持简洁**: 总体流程仍然简单清晰

### 用户体验提升
- ✅ **操作直观**: 按钮显示逻辑清晰
- ✅ **功能完整**: 核销+改期+取消 三大核心操作
- ✅ **安全可靠**: 自动冲突检测，防止时间重叠

### 技术架构改进
- ✅ **事务一致性**: 改期时同步更新预约和课表
- ✅ **性能优化**: 高效的冲突检测查询
- ✅ **可扩展性**: 模块化设计，便于后续功能扩展

---

## 📝 开发注意事项

1. **事务处理**: 改期操作必须保证预约和课表的数据一致性
2. **冲突检测**: 时间冲突检测逻辑要考虑边界情况
3. **权限控制**: 确保不同角色的操作权限正确配置
4. **错误处理**: 提供友好的错误提示和异常处理
5. **性能优化**: 冲突检测查询要进行索引优化
6. **测试覆盖**: 确保关键业务逻辑有完整的单元测试

## 🔄 版本管理

- **当前版本**: v1.0.0 - 基础预约管理功能
- **目标版本**: v1.1.0 - 增加改期功能，优化核销逻辑
- **下一版本**: v1.2.0 - 完善用户体验，增加高级功能

---

*本文档将作为开发实施的严格依据，所有代码修改必须按照此方案执行。*